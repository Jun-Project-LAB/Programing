Python 관련 내용 정리

문자열과 관련되어 사용할 수 있는 함수로 index, find가 있는데 이 둘의 차이점

index, find 모두 문자열에서 주어진 값을 찾는 역할을 한다. 그러나 index의 경우 찾고자 하는 문자열이 있으면 에러가 발생하고 find의 경우 -1 값을 반환한다.
즉, find를 이용하면 해당 문자열을 포함하지 않았을 경우에 대한 조건식, 실행문 등을 만들 수 있다.

index의 사용법은 변수.index("찾을 문자", 시작 위치) 라고 한다. find 또한 index와 기본 사용법에 있어서는 유사한 것 같다.

replace를 사용해 매치되는 문자열을 바꿀 수도 있다. 사용법의 경우 변수.replace("찾을 문자", "바꿀 문자", [치환 횟수]) 이다. 치환 횟수의 경우 지정하지 않았을 경우 기본 동작은 일치하는 문자열을 모두 변경한다고 한다.

문자를 이어서 출력하는 방법은 +와 ,가 있다. +로 이어붙일 경우 바로 이어지게 되고 ,로 이어붙일 경우 중간에 공백이 하나 생긴다.
또한 int형을 +로 이어붙일 경우 str(변수) 와 같이 해줘야 정상적으로 출력이 된다. ,를 사용할 경우 별도로 Casting을 하지 않다도 된다.

여러 줄 주석하는 법==========
주석처리할 줄을 드래그로 선택후 Ctrl + / 해제 할 때는 다시 Ctrl + /

C 언어에서 %d, %s와 같이 쓰던 것을 Python에도 적용할 수 있으나 방식의 차이가 있다. 
C 언어의 경우 값에 넣을 변수를 , 로 구분하였는데 Python의 경우 % 로 구분한다. 즉, 20.0 이라는 값을 정수형으로 출력할 때 아래와 같은 차이점이 있다.

C언어================
printf("%d", 20.0);


Python===============
print("%d" % 20.0)

여러 개의 값을 넣을 경우 소괄호로 묶고 콤마로 구분해주면 된다.

i.e) print("%s %s %s" % ("일", "이", "삼"))

다른 방법으로는 {}와 .format을 이용하는 방법이 있다고 한다. 사용법의 경우 %d, %s와 같이 지정하던 부분을 중괄호로 대체해주고 "출력할 문자열".format(출력값) 으로 해주면 된다.
중괄호에 0, 1과 같이 숫자를 넣어서 입력할 경우 배열과 같이 사용할 수 있는 것 같다. 숫자를 넣는 부분을 변수명으로도 대체할 수 있는데 변수의 값이 꼭 format 함수 안에서 선언되어야 하는 것 같다.

이 방법은 3.6 이상 version에서 사용 가능한 방법이라고 한다.
예를 들어 age, color 변수를 미리 선언해놓고 아래와 같이 출력하면 된다.
print(f"출력할 문자열{age} 어쩌구 저쩌구 {color}")

""로 출력할 문자열을 적어주기 전에 f 를 추가해주면 된다. 아마 format 함수 내에서만 선언해주어야 했던 변수값을 개선한 방안인 것으로 보인다.


=============리스트=============
리스트의 개념은 C 언어에서의 배열과 비슷한 느낌인 것 같다. 다만 C 언어에서의 배열과 다르게 확장성이 있다.
기존 list에서 무언가 항목을 추가하고자 할 때 [list명].append([추가할 항목]) 을 하면 리스트의 맨 뒷쪽에 추가된다.

[list명].insert(추가할 index, [추가할 항목])을 하면 지정한 index에 추가된다.

pop() 함수의 경우 리스트의 맨 뒤에서 하나를 뺀다. 스택에서의 pop과 동일한 개념

sort() 함수의 경우 오름차순으로 정렬해주고 .reverse()의 경우 역순으로 정렬해준다.

clear() 함수의 경우 리스트 내용을 삭제한다.

extend() 함수의 경우 서로 다른 리스트를 확장할 수 있도록 해준다. 사용법은 다음과 같다.
[합칠 list 명].extend([합쳐질 list 명])
뒤에 선언한 리스트의 내용이 앞에 선언한 리스트의 뒤로 합쳐진다.

=============dictionary====================
dictionary의 경우 배열과 비슷한 느낌인데 다른 구조체였다. 형식은 아래와 같이 생겼다.
[Dictionary Name] = { key:value, key2:value2 ~~~ }

값을 가져올 때는 key 값을 기준으로 가져온다. 배열처럼 Dictionary명[key]로 가져오는 법도 있고 Dictionary명.get(key)로 가져오는 방법도 있다.

대괄호를 사용하는 법과 get() 함수를 사용하는 법에 있어서 오류에 대한 대책이 다르다. 대괄호를 사용할 경우 없는 key 값을 인수로 사용하면 프로그램 오류가 발생하며 종료되고, get() 함수를 사용하는 경우 None라는 값을 출력하게 된다.
또한 get() 함수를 사용할 경우 존재하지 않는 key 값에 대해서 None이 아닌 다른 문구를 출력할 수 있다. 방법은 다음과 같다.
Dictionary명.get([Key 값], "존재하지 않는 값에 대해 출력할 문자열")

in 을 사용해서 해당 Key 값이 Dictionary에 존재하는지 boolean 값으로 반환할 수 있다. 사용법은 [key값] in [Dictionary명] 이다.
특정 값에 대해서 추가 혹은 변경하고 싶은 경우 다음과 같이 사용하면 된다. Dictionary명[Key값]=Value
Key 값이 이미 존재하는 key일 경우 새로 입력하는 Value로 변경되며 존재하지 않는 Key 값일 경우 새로운 Key 값이 추가된다.
삭제할 때의 경우 del Dictionary명[key값] 을 통해서 삭제할 수 있다.
key 값들만 출력하고 싶은 경우 Dictionary명.keys() 함수를 사용하면 되고 value만 출력하고 싶은 경우 Dictionary명.values() 함수를 사용하면 된다.
전체 item을 출력할 경우 items() 함수를 사용하면 된다.

=============Tuple===================
List와 비슷한 개념이나 Tuple의 경우 기존에 지정한 값을 수정, 추가, 삭제가 불가능하다. 선언의 경우 Tuple명 = ("Value1", "Value2" ~~)와 같은 식으로 선언하면 된다.
List와 다른 방식으로도 사용할 수 있는 것 같다. 예를 들어 여러 변수에 각각 다른 값을 지정하고자 할 때 다음과 같이 사용할 수 있다.
(age, city, work) = (19, "Incheon", "Student")
그러면 age에 19, city에 Incheon, work에는 Student가 들어가게 된다. 이걸 하나의 다른 개념으로 봐야할 지는 모호하긴 한데 암튼 그렇다고 한다.

============Set====================
이것도 배열의 확장 개념으로 보는게 맞지 않을까 싶다. 기본적으로 중복된 값을 사용할 수 없으며 순서가 없다고 한다.
중복된 값을 아예 집어넣지 못하는 것이 아니라 있을 경우 하나로 합치는 것 같다.
그냥 [변수명] = { 넣을 값들 } 형식으로 해도 사용이 가능한 것 같고, [변수명] = set(["값1", "값2"])와 같은 식으로 해도 되는 것 같다.


& 연산자를 이용해서 교집합 결과도 뽑아낼 수 있는 것 같다. 혹은 [변수1].intersection(변수2) 도 같은 역할

합집합의 경우 | 연산자 혹은 unior 함수

차집합은 - 혹은 difference 함수

add() 함수 혹은 remove() 함수를 통해 추가, 삭제도 가능하다.

type() 함수를 이용해서 변수의 자료형을 알아올 수 있으며 C 언어에서와 같이 명시적 캐스팅이 가능하다. 예를 들어 set 자료형을 list, tuple로 변환하기 위해서는 list(변수명) 혹은 tuple(변수명) 과 같이 할 수 있다.

random 모듈을 import하고 sample을 통해 뽑기를 할 수 있다. 사용법은 sample("리스트 변수", 뽑을 수)
또한 shuffle 함수를 통해서 리스트 내용의 순서를 섞을 수도 있다.

========조건문=========
C 언어에서는 else if 라고 적던 것을 Python에서는 elif 라고 작성한다.
또한 하나의 조건문에서 여러 조건을 걸 때 C 언어에서 || 와 같이 사용하던 거 대신 or, && 대신 and가 사용가능한 것 같다.

input() 함수를 사용해서 값을 입력받을 수 있음. 그냥 기본 형태로 사용할 경우 String으로 받기 때문에 Casting을 통해 다른 자료형으로 변경 가능.

===========for 문==========
for 문의 형식 같은 경우는 for a in [range]와 같은 형태로 사용
for 문을 한 줄로 줄여서 코딩하는 방법이 있다고 한다. 방법의 경우 다음과 같다.
var=list([a*2 for a in old_var])
위와 같은 경우 old_var의 값을 가져와서 var list 변수에 2를 곱한 값을 저장하게 된다. 대략의 형식을 파악해보자면

실행문 for 문 순서로 오는 것을 확인할 수 있다.

======continue & break ==========
break는 자주 사용했는데 continue는 사실 들어는 봤는데 사용할 일이 자주 없었던 것 같다. 암튼 continue를 만났을 경우 하위 명령을 실행하지 않고 다음 반복으로 넘어간다.
여기서 다음 반복이란, 반복문 자체를 빠져나가는 뜻이 아닌 같은 반복문의 다믐 단계로 넘어가는 것을 의미한다. break의 경우 해당 반복문을 아예 중지하고 빠져나온다.

========Custom Function=======
C 언어에 있어서 사용자 정의 함수를 지정하는 방법이 좀 많이 다르다. 형식의 경우 다음과 같다.

def [Function Name]():
	실행할 명령

함수 호출의 경우 함수명() 을 통해 호출할 수 있다.

함수명(인자1, 인자2) 와 같이 인자를 통해 입력 받을 수 있다. 또한 함수 내에서 return을 통해서 결과값을 되돌려줄 수 있다.
return을 활용할 때 단일값만 반환하는 것이 아니라 return a, b, c와 같이 콤마로 구분하여 여러 개의 값을 반환할 수 있다.
물론 함수를 호출하는 부분의 경우 다음과 같이 사용하면 된다. a, b, c = 실행할 함수()

\를 통해서 긴 한 줄의 문장을 여러 줄로 분할할 수 있다.

함수를 선언할 때 (인자이름=값) 형식으로 입력하면 해당 인자에 대한 기본값을 지정할 수 있다.

꼭 함수에서 선언한 순서대로 사용하는 것이 아니여도 함수를 호출할 때 인자명=값 형식으로 지정해서 호출하면 해당하는 인자에 값이 지정된다.

갯수가 변할 수 있는 인자의 경우 매번 함수를 바꿔주거나 빈 값을 넣어줄 수 없다. 따라서 가변인자라는 것이 존재하는데 사용법의 경우 인자 앞에 *(애스터리스크)를 붙이면 된다.
출력할 때의 경우 반복문을 사용하여 출력하거나 하면 된다. 

함수를 사용하다보면 지역 변수와 전역 변수의 차이에 의해 오류가 발생할 수 있다. 예를 들어 전역에서 사용한 변수를 사용자 정의 함수에서 사용하려고 할 경우 이 변수가 지역 변수로 인식되어 사용을 할 수 없다고 한다.
그럴 때 함수 내에서 global [전역 변수명] 을 해주면 해당 전역 변수를 가져와서 사용할 수 있다.
---print---
print를 사용할 때 end=" " 와 같이 지정하면 print 문의 끝이 CR-LF가 아닌 공백 문자 하나를 출력하고 끝내게 된다. 즉, 이를 응용해서 동일한 끝 문장을 사용하는 출력에 대해 일괄적으로 설정이 가능하다.

----------std input, output-------------
print 함수로 출력을 할 때 , 로 구분하면 공백 한 칸으로 구분되어 출력된다는 것을 알 수 있었다. 그러나 sep 를 통해 구분자를 바꿀 수 있었다.
예를 들어 print("Test1", "Test2", "Test3", sep="-") 와 같이 출력할 경우 결과적으로 Test1-Test2-Test3 라고 출력된다.

sys module을 import해서 stdout, stderr 출력을 변경할 수 있다. 사용법은 다음과 같다. file=sys.stdout 혹은 file=sys.stderr

ljust, rjust는 정렬을 위한 함수이다. ljust의 경우 왼쪽 정렬, rjust의 경우 오른쪽 정렬이다. ljust(몇칸) rjust(몇칸) 같이 사용할 수 있으며 변수.ljust(n) 과 같이 사용할 수 있다.
zfill의 경우 C 언어에서 %02d와 같이 자릿수를 맞출 수 있는 기능이다. zero fill의 약자로 지정된 자리에서 빈 자리를 0으로 채운다. 사용법의 경우 변수.zfill(자릿수)

문자 형식 정렬++++++++++++++++
i.e.) print("{0:x>10)".format(500)) 과 같이 출력하였을 경우를 해석
0:x	=> 빈 자리의 경우 x 문자로 대체
>10	=> 오른쪽 정렬 10칸

위 예제에서 10 앞에 + 부호를 추가할 경우 양수일 때는 + 부호를 붙여서 출력하고 음수일 경우 - 부호를 붙여서 출력한다.
{0:,}와 같이 사용할 경우 세 자리마다 콤마를 자동으로 찍어줌.

===========file in, output==========
open("파일명","mode", encoding="~")
mode에는 r, w, a가 있으며 r=read, w=write(뎦어쓰기), a=파일 끝에 추가
추가적으로 b, t를 통해 옵션을 지정할 수 있다. b의 경우 binary, t는 text를 의미한다.
예를 들면 wb, rt 와 같이 사용할 수 있다.

파일명.close() 함수를 통해 닫아주는 것이 좋다.

파일에 값을 입력하는 방법의 경우 두 가지가 있다. print 함수를 이용한 방법, write() 함수를 이용한 방법.
print 함수를 이용한 방법의 경우 print("내용", file="파일명")
write 함수를 이용한 방법의 경우 파일명.write("내용")

print의 경우 기본적으로 출력을 마친 후 CR-LF 문자를 추가하지만 write의 경우 그게 없기에 직접 줄바꿈을 해주어야 한다.

파일을 읽어오는 경우 read() 함수를 사용한다. 파일명.read()
read()의 경우 전체 내용을 읽어오며 readline()의 경우 한 줄씩 읽어온다. readlines()의 경우 리스트 형태로 불러온다.

+++++++++++++pickle++++++++++++++++
pickle은 모듈 중 하나인데 데이터에 있는 내용을 파일로 저장할 수 있다고 한다?..
암튼 import pickle 을 통해 불러올 수 있다. 추가적으로 pickle을 사용하기 위해서는 무조건 Binary 형태로 파일을 사용해야한다.

사용법의 경우 다음과 같다. 데이터를 파일로 쓸 경우 pickle.dump("변수명", "파일명")
반대로 파일에서 가져올 경우에는 "변수명" = pickle.load("파일명")

=============with 문================
with문의 경우 기존에 파일을 열고 닫는 과정을 수동으로 할 필요없이 자동으로 파일을 닫아주기에 편리하다고 하다.
with 문의 형식은 다음과 같다. with expression as "variable":

//////////////////Class////////////////////

'틀' 이라는 개념으로 이해하면 된다. 비슷한 구조를 가진 것이 여러 개가 필요할 경우 유용하게 사용할 수 있다.

기본적인 구조의 경우 다음과 같다.
class [Class명]:
	def __init__(self, 그 외 인수들):
		실행문

__init__ 의경우 이름에서 알 수 있듯이 클래스 실행 시 초기화 되며 실행되는 부분이다.
그 외의 경우 사용자 정의 함수와 같이 자신이 원하는 기능을 추가할 수 있다.

class 내에서 변수를 선언할 때는 self를 이용해서 한다. 예를들면 self.name = " ~ " 와 같이 말이다.
==> 이를 멤버변수라고 한다.

사용법 중 하나로 Class_1 이라는 class에 add, del 기능을 추가하였을 경우 다음과 같은 형식으로 사용할 수 있다.
Calc = Class_1()

print(Calc.add(n))
print(Calc.add(n))

클래스 외부에서 멤버 변수를 호출할 수는 있으나 외부에서 내부로 멤버 변수를 추가할 수는 없다?..

************상속***********
중복되는 속성을 다른 클래스로부터 물려받아서 사용할 수 있는 기능. 상속받는 법은 다음과 같다.
class [class명](상속받을 class명):
	class명.[기능](인자) 을 통해서 상속받은 class에 있는 기능을 사용할 수 있다.
부모 클래스를 두 개 이상 상속 -> 다중 상속
사용법의 경우 크게 다른 건 없고 콤마를 통해서 구분하면 된다.

-------------메소드 오버라이딩--------------
부모 클래스로부터 상속받은 함수를 자식 클래스에서 재정의해서 이를 사용할 수 있음.

^^^^^^^^^pass^^^^^^^^^^^
말 그대로 pass를 할 수 있다. 해당 구문을 만났을 경우 아무것도 처리하지 않고 넘어간다.

@@@@@@super@@@@@@
기존 부모클래스명.함수 방식으로 하던 것을 super().함수 와 같은 형식으로 대체할 수 있다.
super를 사용할 경우 self를 빼주어야 한다.
단일 상속의 경우 관계가 없지만 다중 상속을 하였을 경우 가장 먼저 상속 받은 것을 super()로 통해 호출한다.

++++++예외처리+++++++
자바에서는 try ~ catch이지만 Python try: except [error]: 형식으로 사용
except [error] as [name] 과 같은 형식으로 해서 특정 변수명으로 에러 내용을 지정할 수도 있다.
그리고 그 내용을 출력할 수도 있다.
특정 에러가 아닌 모든 에러에 대해 같은 오류 문구를 출력하려면 그냥 except: 로 지정하고 print 해주면 된다.
혹은 에러의 내용을 출력하고자 한다면 except Exception as [name]: 으로 지정 후 그 내용을 출력하는 방법도 있는 것 같다.

특정 상황에 대하여 자신이 에러를 발생시키고자 한다면 raise를 사용하면 된다. 사용법의 경우 raise [error name] 후 except 문에서 에러를 처리하게 된다.
raise로 예외 처리를 한 것에서 한번 더 raise를 호출하는 re-raise도 있다고 한다.

exception을 상속받음으로써 사용자 정의 에러를 만들 수도 있다. 정의 방법의 경우 class [error명](Exception):	pass 와 같이 사용할 수 있다.
=> 상속받을 때 까다로운 것이 반드시 Exception으로 입력해주어야 한다. 대소문자를 지키지 않을 경우 제대로 상속받지 못한다.

finally 문의 경우 try ~ exception ~ finally 형식에서 마지막으로 사용되며 오류 발생 여부와 관계없이 마지막에 호출된다고 한다.

~~~~~~~~~~~모듈~~~~~~~~~~
재사용의 극대화를 할 수 있는 기능 중 하나로 파일 확장자의 경우 .py 라고 함.
다른 모듈을 사용하는 방법의 경우 import [module file name] 을 통해 사용할 수 있으며 뒤에 as 를 통해 다른 별칭을 지정하여 사용할 수도 있다.
file name의 경우 extension을 제외하고 적어주면 된다.

from 형식으로 import하는 방법도 있으며 from [file name] import * 과 같이 지정하면 해당 file의 모든 기능을 import 한다는 의미이다.
특정 기능만 import 하고 싶은 경우 * 부분을 자신이 불러오고자 하는 기능으로 대체하면 된다.

각각의 방식에 따라 차이점이 있는데 정리하면 다음과 같다.

import [file_name]	=> file_name.[function]()

import [file_name] as file => file.[function]()

from [file_name] import * => [function]()

************패키지****************
모듈들의 집합
import [Package].[Module] 과 같은 형식으로 사용 가능
그리고 [Package].[Module].[Class]와 같은 형식으로 불러올 수 있음.
from ~ import를 사용하면 class를 직접적으로 불러올 수 있다.

__all__

from Package import * 을 해도 module.class와 같은 형식으로 사용이 안될 때가 있다고 한다.
이 경우 공개 범위를 지정한 것에 따라 다르다고 한다.

이럴 때 __all__ = [(Module Name)] 과 같이 지정해주면 (아마 __init__ 구문 쪽에서) 제대로 호출이 가능하다.

if문을 이용하여 조건을 __name__ == "__main__" 과 같이 걸어주면 해당 모듈을 직접 실행할 때만 특정 행동을 수행하도록 지정할 수 있다.
이러한 동작을 보아 Python의 경우 직접적으로 실행되는 파일을 main으로 지정하는 것으로 보인다.

_____________________inspect___________________
모듈 중 하나로 inspect.getfile(모듈명) 과 같이 사용했을 때 해당 모듈이 어느 경로에 있는지 알려준다.
다른 파일에 대해서도 사용이 가능하지 않을까 싶다. 예를 들어 open 같은 것을 쓴다던가..

내장 함수 & 외장 함수

내장 함수의 경우 import를 하지 않아도 바로 사용할 수 있는 함수들. 외장 함수의 경우 import를 하여 사용하는 함수들

내장 함수의 종류 : input(입력), dir(객체를 입력값으로 받아 어떤 변수와 함수가 있는지 표시) 등등
그 외의 종류는 아래 링크에서 확인 가능하다고 한다.
https://docs.python.org/3/library/functions.html		=> 버전, 언어를 선택하여 보면 된다.

외장 함수의 경우 아래 링크에서 확인할 수 있다.
https://docs.python.org/3/py-modindex.html

